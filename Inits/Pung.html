<!DOCTYPE html>
<html>
<!--
Code by Dreysion
Done on basic Notepad to prove I can
First time implementing my own Vector math, not built into a game engine
I'm a bit proud
-->
	<head>
		<title>Pung</title>
		<style>
div {
	position: absolute;
	border: 1px solid #000000;
	background-color: #FFFFFF;
}

#playground {
	background-color: #454545;
	overflow: hidden;
}

#ball {
	border-radius: 6px;
}

#bounds {
	background-color: transparent;
	border: 3px solid #FFFFFF;
}
		</style>
		<script>
//-----------------------------------------------------------------------//


///////////////////////////////////////////////////////////////////////////
//                                 Setup                                 //
///////////////////////////////////////////////////////////////////////////
var playing

function loadStuff(){
	W = window.innerWidth;
	H = window.innerHeight;
	Vector0 = new Vector2(0,0);

		//Game controls//
	up1 = false;
	up2 = false;
	down1 = false;
	down2 = false;
	pause = false;

		//AI// //name, accuracy, confidence, preemption, recheck, fidget//
	aiList = [
		new AI("Martha", 0.3, 0.3, 0.9, 0.7, 0.6)
	];
	cRange = false;

		//Game variables//
	ballSpeed = 5;
	ballAngle = (Math.random() * 2 * Math.PI) - Math.PI;
	paddleSpeed = 10;
	paddleSize = 60;
	paddleExtents = 15;

		//Game init//
	ai = aiList[0];
	win = false;
	update = setInterval(function(){updateGame();}, 30);
	playing = true;

		//HTML//
	pg = new Box("playground", W * 0.025, H * 0.175, W * 0.95, H * 0.8);
	pg.div.style.left = pg.pos.x + "px";
	pg.div.style.top = pg.pos.y + "px";
	p1 = new Box("player1", W * 0.1, pg.height / 2, 10, paddleSize);
	p2 = new Box("player2", pg.width - (W * 0.1), pg.height / 2, 10, paddleSize);
	ball = new Box("ball", pg.width / 2, pg.height / 2, 10, 10);
	ball.velocity.x = ballSpeed * Math.cos(ballAngle);
	ball.velocity.y = ballSpeed * Math.sin(ballAngle);
	bound = new Box("bounds", pg.width / 2, pg.height / 2, pg.width * 0.9, pg.height * 0.9);
}

function restart() {
	win = false;
	p1.pos.y = pg.height / 2;
	p2.pos.y = pg.height / 2;
	ball.pos = new Vector2(pg.width / 2, pg.height / 2);
	ballAngle = (Math.random() * 2 * Math.PI) - Math.PI;
	ball.velocity = new Vector2(ballSpeed * Math.cos(ballAngle), ballSpeed * Math.sin(ballAngle))
}

function winner(which) {
	pause = true;
	win = which;
	console.log(which + " wins!");
}


///////////////////////////////////////////////////////////////////////////
//                                Objects                                //
///////////////////////////////////////////////////////////////////////////

function Box(id, left, top, width, height) { 
	this.div = document.getElementById(id);
	this.pos = new Vector2(left, top);
	this.width = width;
	this.height = height;

	this.div.style.left = left - (width / 2) + "px";
	this.div.style.top = top - (height / 2) + "px";
	this.div.style.width = width + "px";
	this.div.style.height = height + "px";

	this.velocity = new Vector2(0,0);
}

function Range(a, b){
	this.a = a;
	this.b = b;
	this.min = Math.min(a,b);
	this.max = Math.max(a,b);
	this.length = this.max - this.min;

	this.random = function(){
		return Math.random() * this.min + this.length;
	}
	this.inRange = function(pos, length){
		return (pos - length / 2 < this.max) && (pos + length / 2 > this.min);
	}
	//this.log = function(){
	//	console.log("("+this.min + ", " + this.max + ")");
	//}
}

function Vector2(x, y){
		//Basic properties//
	this.x = x;
	this.y = y;
	this.angle = function(){
		return Math.atan2(this.y, this.x);
	}
	this.magnitude = function(){
		return Math.sqrt((this.x * this.x) + (this.y * this.y));
	}
	this.normalized = function(){
		return new Vector2(this.x / this.magnitude(), this.y / this.magnitude());
	}

		//Less complicated Vector math//
	this.equals = function(VectorB){
		return ((this.x == VectorB.x) && (this.y == VectorB.y));
	}
	this.subtract = function(VectorB){
		return new Vector2(this.x - VectorB.x, this.y - VectorB.y);
	}
	this.add = function(VectorB){
		return new Vector2(this.x + VectorB.x, this.y + VectorB.y);
	}
	this.extend = function(magnitude, VectorB){
		return this.add(VectorB.normalized().multiply(magnitude));
	}

	this.multiply = function(value){
		return new Vector2(this.x * value, this.y * value);
	}
	this.cross = function(VectorB){
		return (this.x * VectorB.y) - (this.y * VectorB.x);
	}
	this.dot = function(VectorB){
		return this.x * VectorB.x + this.y * VectorB.y;
	}

		//More complicated math//
	this.toZero = function(decel){
		x = Math.abs(this.x) - decel;
		if(x < 0) x = 0;
		x = x * sign(this.x);
		y = Math.abs(this.y) - decel;
		if(y < 0) y = 0;
		y = y * sign(this.y);

		return new Vector2(x, y);
	}
	this.accel = function(VectorB, decel){
		if(VectorB.equals(Vector0)) {
			return this.toZero(decel);
		}
		return this.add(VectorB);
	}

	this.rotate = function(modAngle){
		newAngle = this.angle() + modAngle;
		return new Vector2(this.magnitude() * Math.cos(newAngle), this.magnitude() * Math.sin(newAngle));
	}
	this.reflect = function(normal){
		flip = this.multiply(-1);
		angleToNormal = Math.acos(flip.dot(normal) / (this.magnitude() * normal.magnitude()));
		return normal.rotate(angleToNormal).multiply(this.magnitude());
	}

	//this.log = function(){
	//	console.log("(" + this.x + ", " + this.y + ")");
	//}
}

function Line(PointA, PointB){
	this.p = PointA;
	this.r = PointB;
	this.length = Math.sqrt((PointB.x - PointA.x) * (PointB.x - PointA.x) + (PointB.y - PointA.y) * (PointB.y - PointA.y));
	this.center = new Vector2((this.p.x + this.r.x) / 2, (this.p.y + this.r.y) / 2);
	this.normal1 = new Vector2(-(PointB.y - PointA.y),PointB.x - PointA.x).normalized();
	this.normal2 = new Vector2(PointB.y - PointA.y, -(PointB.x - PointA.x)).normalized();

	this.collide = function(LineB) {
			//This is the part I copy/pasted//
		d1 = this.p.subtract(LineB.p).cross(LineB.r.subtract(LineB.p));
		d2 = this.r.subtract(LineB.p).cross(LineB.r.subtract(LineB.p));
		d3 = LineB.p.subtract(this.p).cross(this.r.subtract(this.p));
		d4 = LineB.r.subtract(this.p).cross(this.r.subtract(this.p));

		t = ((this.p.x - LineB.p.x) * (this.p.y - this.r.y) - (this.p.y - LineB.p.y) * (this.p.x - this.r.x)) /
			((this.p.x - this.r.x) * (LineB.p.y - LineB.r.y) - (this.p.y - this.r.y) * (LineB.p.x - LineB.r.x));
		
		collision = (((d1 < 0 && d2 > 0) || ((d1 > 0 && d2 < 0))) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0)));

		if(collision){
			collisionPoint = new Vector2((this.p.x + t * (this.r.x - this.p.x)), (this.p.y + t * (this.r.y - this.p.y)));
			collisionNormal = LineB.normal1;
			collisionFromCenter = (collisionPoint.y - this.center.y) / (this.center.y - this.p.y);
			collisionT = t;

			//colllisionLog = console.log("Collision at point " + collisionPoint.log());
		}
		
		return collision;
	}

	//this.log = function(){
	//	console.log(this.p.log() + this.r.log());
	//}
}

function AI(name, accuracy, confidence, preemption, recheck, fidget) {
	this.name = name;

		//All values from 0.01 to 0.99//
		//First calculate where ball should hit//
		//Accuracy is an area around that point that AI guesses the ball will go//
	this.accuracy = accuracy;
		//Confidence is the area around the chosen accuracy point that AI feels safe to be in//
	this.confidence = confidence;
		//Preemption is how soon AI moves to catch the ball//
	this.preemption = preemption;
		//Recheck is how often AI updates calculations//
	this.recheck = recheck;
		//Fidget affects actions when AI isn't trying to catch the ball//
	this.fidget = fidget;

	this.checkInterval = 50;

	this.calculateHit = function(){
		ballppos = new Vector2(ball.pos.x, ball.pos.y);
		ballpvel = new Vector2(ball.velocity.x, ball.velocity.y);

		collisionTop = new Line(new Vector2(p1.pos.x + p1.width / 2, bound.pos.y - bound.height / 2), new Vector2(p2.pos.x - p2.width / 2, bound.pos.y - bound.height / 2));
		collisionRight = new Line(new Vector2(p2.pos.x - p2.width / 2, bound.pos.y - bound.height / 2), new Vector2(p2.pos.x - p2.width / 2, bound.pos.y + bound.height / 2));
		collisionBottom = new Line(new Vector2(p2.pos.x - p2.width / 2, bound.pos.y + bound.height / 2), new Vector2(p1.pos.x + p1.width / 2, bound.pos.y + bound.height / 2));
		collisionLeft = new Line(new Vector2(p1.pos.x + p1.width / 2, bound.pos.y + bound.height / 2), new Vector2(p1.pos.x + p1.width / 2,bound.pos.y - bound.height / 2));

		mathTarget = false;
		bounceCount = 0;
		while(!mathTarget){
			ballProjection = new Line(ballppos, ballppos.extend(1000,ballpvel));
			if(ballProjection.collide(collisionTop)){
				console.log(bounceCount+"top");
				pPoint = new Vector2(collisionPoint.x, collisionPoint.y);
				pVelocity = ballpvel.reflect(collisionNormal);
			}
			if(ballProjection.collide(collisionBottom)){
				console.log(bounceCount+"bottom");
				pPoint = new Vector2(collisionPoint.x, collisionPoint.y);
				pVelocity = ballpvel.reflect(collisionNormal);
			}
			if(ballProjection.collide(collisionLeft)){
				console.log(bounceCount+"left");
				pPoint = new Vector2(collisionPoint.x, collisionPoint.y);
				pVelocity = ballpvel.reflect(collisionNormal);
			}
			if(ballProjection.collide(collisionRight)){
				console.log(bounceCount+"right");
				pPoint = new Vector2(0,0);
				pVelocity = new Vector2(0,0);
				mathTarget = new Vector2(collisionPoint.x, collisionPoint.y);
			}
			console.log("("+ballProjection.p.x+","+ballProjection.p.y+"),("+ballProjection.r.x+","+ballProjection.r.y+")");
			if(collisionPoint) console.log("("+collisionPoint.x+","+collisionPoint.y+")");
			ballppos = new Vector2(pPoint.x, pPoint.y);
			ballpvel = new Vector2(pVelocity.x, pVelocity.y);
			bounceCount++;
			if(bounceCount > 50) break;
		}
		return mathTarget;
	}
}


///////////////////////////////////////////////////////////////////////////
//                                 Input                                 //
///////////////////////////////////////////////////////////////////////////

function keyDown(event) {

		//W//
	if(event.keyCode == 87){
		up1 = true;
	}

		//S//
	if(event.keyCode == 83){
		down1 = true;
	}

		//up//
	if(event.keyCode == 38){
		up2 = true;
	}

		//down//
	if(event.keyCode == 40){
		down2 = true;
	}

		//space//
	if(event.keyCode == 32){
		if(win) restart();
		pause = !pause;
	}
}

function keyUp(event) {

		//W//
	if(event.keyCode == 87){
		up1 = false;
	}

		//S//
	if(event.keyCode == 83){
		down1 = false;
	}

		//up//
	if(event.keyCode == 38){
		up2 = false;
	}

		//down//
	if(event.keyCode == 40){
		down2 = false;
	}
}


///////////////////////////////////////////////////////////////////////////
//                               Intervals                               //
///////////////////////////////////////////////////////////////////////////

function updateGame() {
	if(!pause){
			//Update Player1//
		Accel = new Vector2(0,0);
		if(up1 || (ai && up2)){
			Accel.y = -2;
		}
		if(down1 || (ai && down2)){
			Accel.y = 2;
		}
		p1.velocity.y = clamp(p1.velocity.accel(Accel, 1).y, -paddleSpeed, paddleSpeed);
		p1.pos = p1.pos.add(p1.velocity);
		p1.pos.y = clamp(p1.pos.y, bound.pos.y - bound.height / 2 + p1.height / 2, bound.pos.y + bound.height / 2 - p1.height / 2);
		p1.div.style.top = p1.pos.y - (p1.height / 2) + "px"
	
			//Update Player2//
		Accel = new Vector2(0,0);
		if(!ai && up2){
			Accel.y = -2;
		}
		if(!ai && down2){
			Accel.y = 2;
		}

///////////////////////////////////////////////////////////////////////////
//                                   AI                                  //
///////////////////////////////////////////////////////////////////////////
		if(ai){
			ai.checkInterval -= ai.recheck;
			if(ai.checkInterval <= 0){
				console.log("checking");
				ai.checkInterval += 50;
				if(ball.velocity.x > 0 && ball.x + ball.velocity.x > pg.width / 2){
					ai.checkInterval -= 30;
				}
				mTarget = ai.calculateHit();
				bLine = new Line(ball.pos, mTarget);
				bDistance = bLine.length;
				aRange = new Range(mTarget.y-(bDistance/ai.accuracy),mTarget.y+(bDistance/ai.accuracy));
				aTarget = new Vector2(p2.pos.x, aRange.random());
				cRange = new Range(aTarget.y-(bounceCount/ai.confidence),aTarget.y+(bounceCount/ai.confidence));
			}
			if(cRange && !cRange.inRange(p2.pos,p2.height) && bDistance < ai.preemtion * 100){
				if(p2.pos.y + p2.height / 2 < cRange.min){
					Accel.y = 2;
				}
				if(p2.pos.y - p2.height / 2 > cRange.max){
					Accel.y = -2
				}
			}else{
				rngCheck = Math.random();
				if(rngCheck < ai.fidget / 4){
					ai.fup = true;
					ai.fdown = false;
				}else if(rngCheck < ai.fidget / 2){
					ai.fup = false;
					ai.fdown = true;
				}else if(rngCheck < 3 * ai.fidget / 4){
					ai.fup = !ai.fup;
				}else if(rngCheck < ai.fidget){
					ai.fdown = !ai.fdown;
				}

				Accel.y = 0;
				if(ai.fup) Accel.y -= 2;
				if(ai.fdown) Accel.y += 2;
			}
		}
		p2.velocity.y = clamp(p2.velocity.accel(Accel, 1).y, -paddleSpeed, paddleSpeed);
		p2.pos = p2.pos.add(p2.velocity);
		p2.pos.y = clamp(p2.pos.y, bound.pos.y - bound.height / 2 + p2.height / 2, bound.pos.y + bound.height / 2 - p2.height / 2);
		p2.div.style.top = p2.pos.y - (p2.height / 2) + "px";

///////////////////////////////////////////////////////////////////////////
//                               Collisions                              //
///////////////////////////////////////////////////////////////////////////
		projectedEnd = ball.pos.add(ball.velocity).extend(ball.width / 2, ball.velocity);
		projectedPath = new Line(ball.pos.extend(ball.width / 2, ball.velocity), projectedEnd);
		topBound = new Line(new Vector2(bound.pos.x - bound.width / 2, bound.pos.y - bound.height / 2), new Vector2(bound.pos.x + bound.width / 2, bound.pos.y - bound.height / 2));
		rightBound = new Line(new Vector2(bound.pos.x + bound.width / 2, bound.pos.y - bound.height / 2), new Vector2(bound.pos.x + bound.width / 2, bound.pos.y + bound.height / 2));
		bottomBound = new Line(new Vector2(bound.pos.x + bound.width / 2, bound.pos.y + bound.height / 2), new Vector2(bound.pos.x - bound.width / 2, bound.pos.y + bound.height / 2));
		leftBound = new Line(new Vector2(bound.pos.x - bound.width / 2, bound.pos.y + bound.height / 2), new Vector2(bound.pos.x - bound.width / 2,bound.pos.y - bound.height / 2));
		player1 = new Line(new Vector2(p1.pos.x + p1.width / 2, p1.pos.y + p1.height / 2), new Vector2(p1.pos.x + p1.width / 2, p1.pos.y - p1.height / 2));
		player1a = new Line(new Vector2(p1.pos.x + p1.width / 2, p1.pos.y - p1.height / 2), new Vector2(p1.pos.x, p1.pos.y - p1.height / 2 - paddleExtents));
		player1b = new Line(new Vector2(p1.pos.x, p1.pos.y + p1.height / 2 + paddleExtents), new Vector2(p1.pos.x + p1.width / 2, p1.pos.y + p1.height / 2));
		player2 = new Line(new Vector2(p2.pos.x - p2.width / 2, p2.pos.y - p2.height / 2), new Vector2(p2.pos.x - p2.width / 2, p2.pos.y + p2.height / 2));
		player2a = new Line(new Vector2(p2.pos.x, p2.pos.y - p2.height / 2 - paddleExtents), new Vector2(p2.pos.x - p2.width / 2, p2.pos.y - p2.height / 2));
		player2b = new Line(new Vector2(p2.pos.x - p2.width / 2, p2.pos.y + p2.height / 2), new Vector2(p2.pos.x, p2.pos.y + p2.height / 2 + paddleExtents));

		collisionPoint = null;
		if(projectedPath.collide(topBound)){
			ball.velocity.y = Math.abs(ball.velocity.y);
		}
		if(projectedPath.collide(rightBound)){
			winner("Player 1");
		}
		if(projectedPath.collide(bottomBound)){
			ball.velocity.y = Math.abs(ball.velocity.y) * -1;
		}
		if(projectedPath.collide(leftBound)){
			winner("Player 2");
		}
		if(projectedPath.collide(player1)){
			ball.velocity.x = Math.abs(ball.velocity.x);
			ball.velocity = ball.velocity.rotate(-collisionFromCenter * Math.PI / 4);
		}
		if(projectedPath.collide(player2)){
			ball.velocity.x = Math.abs(ball.velocity.x) * -1;
			ball.velocity = ball.velocity.rotate(collisionFromCenter * Math.PI / 4);
		}
		if(projectedPath.collide(player1a) || projectedPath.collide(player1b) ||
				projectedPath.collide(player2a) || projectedPath.collide(player2b)){
			ball.velocity = ball.velocity.reflect(collisionNormal);
		}

			//Update Ball//
		ball.pos = ball.pos.add(ball.velocity);
		if(collisionPoint){
			ball.pos = collisionPoint.extend(ball.width / 2, collisionNormal);
			console.log("!!!("+collisionPoint.x+","+collisionPoint.y+")");
		}
		
		ball.div.style.left = ball.pos.x - ball.width / 2 + "px";
		ball.div.style.top = ball.pos.y - ball.height / 2 + "px";
	}
}

/*
//I recognize my collision handling isn't clean. I understand it better
//now that I've worked with it, future projects should be nicer to look at.
//
//Also, there are bugs. For example, you can hit the ball with the edge of
//the paddle to bounce it to the main body of the same paddle and get two
//hits in one. Kinda weird angles, but not game breaking, so I'll leave it.
//
//It's a feature!
*/

///////////////////////////////////////////////////////////////////////////
//                                Utility                                //
///////////////////////////////////////////////////////////////////////////

function clamp(value, min, max) {
	return Math.min(Math.max(value, min), max);
}

	//Returns -1 or 1 if the value isn't 0//
function sign(value) {
	if(!value) return 0;
	return value / Math.abs(value)
}

//-----------------------------------------------------------------------//
		</script>
	</head>
	<body onload="loadStuff()" onkeydown="keyDown(event)" onkeyup="keyUp(event)">
		<div id="playground">
			<div id="player1"></div>
			<div id="player2"></div>
			<div id="ball"></div>
			<div id="bounds"></div>
		</div>
	</body>
</html>