<!DOCTYPE html>
<html>
<!--
Code by Dreysion
Done on basic Notepad to prove I can
First time implementing my own Vector math, not built into a game engine
I'm a bit proud
-->
	<head>
		<title>Pung</title>
		<style>
* {
	margin: 0;
	padding: 0;
}

h1 {
	margin-top: 75px;
	text-align: center;
	font-size: 48px;
}

h2, h3 {
	text-align: center;
}

h3 {
	margin: 35px;
}

body {
	background-color: #454556;
}

canvas {
	margin-top: 50px;
	border: 1px solid #000000;
	background-color: #000000;
} 

#status {
	position: relative;
	height: 80px;
	opacity: 0.6;
}

#status:hover {
	opacity: 0.9;
}

#status div {
	position: absolute;
	height: 40px;
	border: 1px solid #FFFFFF;
	padding: 20px;
	color: #FFFFFF;
	overflow: hidden;
}

#menu {
	position: absolute;
	border: 1px solid #000000;
	background-color: #676778;
}

#newgame {
	position: absolute;
	bottom: 20px;
	left: 50%;
	transform: translate(-50%,0);
}

.half {
	position: absolute;
	border: 1px solid #000000;
	overflow-y: scroll;
}

.margin {
	margin-left: 40px;
	margin-right: 40px;
}

label {
	display: inline-block;
	min-width: 100px;
	text-align: right;
}

input[type="text"] {
	width: 80px;
}

input[type="number"] {
	width: 40px;
}

#splash {
	position: absolute;
	left: 0px;
	padding-top: 40px;
	padding-bottom: 40px;
	width: 100%;
	background-color: #686868;
	color: #FFFFFF;
	border-top: 5px solid #FFFFFF;
	border-bottom: 5px solid #FFFFFF;
	text-align: center;
	font-size: 60px;
	opacity: 0.4;
	display: none;
}

::-webkit-scrollbar {
	width: 10px;
}



::-webkit-scrollbar-thumb {
	background: #121223;
	border-radius: 5px;
}
		</style>
		<script>
//-----------------------------------------------------------------------//


///////////////////////////////////////////////////////////////////////////
//                                 Setup                                 //
///////////////////////////////////////////////////////////////////////////

var pg;
var st;
var test;
var mn;
var sp;
var ctx;
var gWidth = 0;
var gHeight = 0;

var win;
var winCount;
var rounds = 0;
var ai = true;
var p1;
var p2;
var pai;
var ball;

var hitPoints = [];
var AIModels = [	//name,color,attention,accuracy,confidence,animation//
	new AI("Lenny","yellow",0.7,0.9,1,0.2),
	new AI("Martha","magenta",0.9,0.6,0.2,1)
];

//helpful visualizations
var showAI = false;
var showBallPath = true;
var showGoalHit = true;
var goal;
var goalTarg;
var goalColor = "white";
var goalGlow = 0;
var showGuessRange = true;
var showGoalGuess = true;
var showGoalRange = true;

var p1Score = 0;
var p2Score = 0;
var p1Name = "Player 1";
var p2Name = "Player 2";
var p1Color = "white";
var p2Color = "white";
var ballColor = "white";
var ballColor2 = [255,255,255];
var hits = 0;
var hitsMax = 0;
var velocity = 0;
var velMax = 0;

var touch = new Vector2(0,0);
var dblTap = false;

var left = false;
var up = false;
var right = false;
var down = false;
var left2 = false;
var up2 = false;
var right2 = false;
var down2 = false;

var time = 0;
var game = false;
var pause = true;

function loadStuff(){
	var w = window.innerWidth - 40;
	var h = window.innerHeight - 240;
	gWidth = (w > h * 5/3) ? h * 5/3 : w;
	gHeight = (w > h * 5/3) ? h : w * 3/5;

	pg = document.getElementById("playground");
	st = document.getElementById("status");
	test = document.getElementById("testdiv");
	mn = document.getElementById("menu");
	sp = document.getElementById("splash");

	ctx = pg.getContext("2d", {willReadFrequently: true});

	p1 = new Paddle();
	p2 = new Paddle();
	ball = new Ball();
	layout();

	window.addEventListener('resize', layout);
	window.addEventListener('touchmove', (e) => {touchHandle(e)});
	window.addEventListener('touchstart', (e) => {touchHandle(e)});
	window.addEventListener('touchend', (e) => {
		if(e.touches.length == 0) {
			touch.x = 0;
			touch.y = 0;
		}
	});
	window.requestAnimationFrame(update);

	//newGame();
}

function layout(){
	var w = window.innerWidth - 40;
	var h = window.innerHeight - 240;
	gWidth = (w > h * 5/3) ? h * 5/3 : w;
	gHeight = (w > h * 5/3) ? h : w * 3/5;

	pg.width = gWidth;
	pg.height = gHeight;
	pg.style.marginLeft = (window.innerWidth - gWidth) / 2 + "px";
	st.style.width = gWidth + "px";
	st.style.marginTop = -gHeight + "px";
	st.style.marginLeft = (window.innerWidth - gWidth) / 2 + "px";
	for (var n in st.children) {
		if(!isNaN(n)){
			st.children[n].style.width = gWidth / 4 - 42 + "px";
			st.children[n].style.left = gWidth / 4 * n + "px";
		}
	}
	mn.style.width = gWidth + "px";
	mn.style.height = gHeight + "px";
	mn.style.left = (window.innerWidth - gWidth) / 2 + 8 + "px";
	mn.style.top = "212px";
	sp.style.top = window.innerHeight / 2 - 75 + "px";

	for(var div in document.getElementsByClassName("half")) {
		if(!isNaN(div)) {
			document.getElementsByClassName("half")[div].style.width = gWidth / 2 - 4 + "px";
			document.getElementsByClassName("half")[div].style.height = gHeight - 120 + "px";
		}
	}
	document.getElementById("right").style.right = "0px";

	p2.position.x = gWidth-80;

	pgPos = new Vector2(pg.getBoundingClientRect().x, pg.getBoundingClientRect().y);
}

function newGame() {
	ai = document.getElementById("player-ai").checked;
	p1Name = document.getElementById("name-p1").value;
	document.getElementById("p1").innerHTML = p1Name;
	p1Color = document.getElementById("color-p1").value;
	if(ai) {
		pai = AIModels[document.getElementById("name-ai").value];
		p2Name = pai.name;
		p2Color = pai.color;
		
	} else {
		p2Name = document.getElementById("name-p2").value;
		p2Color = document.getElementById("color-p2").value;
	}
	checkColors();
	document.getElementById("p2").innerHTML = p2Name;

	if(document.getElementById("win-rounds").checked) win = "rounds";
	else if(document.getElementById("win-points").checked) win = "points";
	else if(document.getElementById("win-bounces").checked) win = "bounces";
	else win = "never";

	if(win == "rounds") {
		winCount = document.getElementById("count-rounds").value;
	} else if(win == "points") {
		winCount = document.getElementById("count-points").value;
	} else if(win == "bounces") {
		winCount = document.getElementById("count-bounces").value;
	}
	if(!winCount) win = "never";

	p1Score = 0;
	p2Score = 0;
	hitsMax = 0;
	velMax = 0;

	p1.position.y = gHeight / 2;
	p2.position.y = gHeight / 2;
	ball = new Ball();
	ball.color = "white";

	mn.style.visibility = "hidden";
	pause = false;

	score();
	hit();
	speed();
	projTraj();

	game = true;
}

function gameOver() {
	pause = true;
	game = false;

	if(p1Score > p2Score) {
		splash(p1Name + " wins!");
	} else if(p2Score > p1Score) {
		splash(p2Name + " wins!");
	} else {
		splash("Draw!");
	}
}

function score() {
	document.getElementById("p1score").innerHTML = p1Score;
	document.getElementById("p2score").innerHTML = p2Score;
}

function hit() {
	if(hits > hitsMax) hitsMax = hits;
	document.getElementById("hits").innerHTML = hits;
	document.getElementById("hitsmax").innerHTML = hitsMax;
}

function speed() {
	if(ball.velocity.magnitude().toFixed(2) > velMax) velMax = ball.velocity.magnitude().toFixed(2);
	document.getElementById("speed").innerHTML = ball.velocity.magnitude().toFixed(2);
	document.getElementById("speedmax").innerHTML = velMax;
}

function splash(text) {
	var s = document.getElementById("splash");
	s.innerHTML = text;
	s.style.display = "block";
}

///////////////////////////////////////////////////////////////////////////
//                                Objects                                //
///////////////////////////////////////////////////////////////////////////

function Range(a, b) {
	this.a = a;
	this.b = b;
	this.min = Math.min(a,b);
	this.max = Math.max(a,b);
	this.length = this.max - this.min;
	
	this.limit = function(min, max) {
		return new Range(Math.max(this.a, min), Math.min(this.b, max));
	}
	this.random = function(){
		return Math.random() * this.length + this.min;
	}
	this.inRange = function(pos, length){
		return (pos - length / 2 < this.max) && (pos + length / 2 > this.min);
	}
	this.log = function(){
		console.log("("+this.min + ", " + this.max + ")");
	}
}

function Vector2(x, y) {
	this.x = x;
	this.y = y;
	this.angle = function() {
		return Math.atan2(this.y, this.x);
	}
	this.magnitude = function() {
		return Math.sqrt((this.x * this.x) + (this.y * this.y));
	}
	this.normalized = function() {
		return new Vector2(this.x / this.magnitude(), this.y / this.magnitude());
	}

	this.subtract = function(VectorB) {
		return new Vector2(this.x - VectorB.x, this.y - VectorB.y);
	}
	this.add = function(VectorB) {
		return new Vector2(this.x + VectorB.x, this.y + VectorB.y);
	}
	this.addMag = function(value) {
		var newMag = this.magnitude() + value;
		var scale = newMag / this.magnitude();
		return new Vector2(this.x * scale, this.y * scale);
	}
	this.multiply = function(value) {
		return new Vector2(this.x * value, this.y * value);
	}
	this.divide = function(value) {
		return new Vector2(this.x / value, this.y / value);
	}
	this.cross = function(VectorB) {
		return (this.x * VectorB.y) - (this.y * VectorB.x);
	}
	this.cross3 = function(VectorB) {
		var x = this.y * 1 - 1 * VectorB.y;
		var y = 1 * VectorB.x - this.x * 1;
		var z = this.x * VectorB.y - this.y * VectorB.x;
		return new Vector3(x,y,z);
	}
	this.dot = function(VectorB) {
		return this.x * VectorB.x + this.y * VectorB.y;
	}
	this.hadamard = function(VectorB) {
		return new Vector2(this.x * VectorB.x, this.y * VectorB.y);
	}

	this.limit = function(magnitude) {
		if(this.magnitude() <= magnitude){
			return this;
		}
		var unit = this.divide(this.magnitude());
		return unit.multiply(magnitude);
	}
	this.rotate = function(angle) {
		newAngle = this.angle() + angle;
		return new Vector2(this.magnitude() * Math.cos(newAngle), this.magnitude() * Math.sin(newAngle));
	}

	this.log = function() {
		return "("+this.x.toFixed(2)+", "+this.y.toFixed(2)+")";
	}
}

function Vector3(x, y, z) {
	this.x = x;
	this.y = y;
	this.z = z;

	this.cross = function(VectorB) {
		var x = this.y * VectorB.z - this.z * VectorB.y;
		var y = this.z * VectorB.x - this.x * VectorB.z;
		var z = this.x * VectorB.y - this.y * VectorB.x;
		return new Vector3(x,y,z);
	}
}

function Line(pointA, pointB) { //pointB must be vertical or horizontal
	this.pointA = pointA;
	this.pointB = pointB;
	this.length = Math.sqrt((this.pointB.x - this.pointA.x) * (this.pointB.x - this.pointA.x) + (this.pointB.y - this.pointA.y) * (this.pointB.y - this.pointA.y));
	this.center = new Vector2((this.pointA.x + this.pointB.x) / 2, (this.pointA.y + this.pointB.y) / 2);

	this.localVector = this.pointB.subtract(this.pointA).normalized();

	this.intersect = function(LineB) {
		var vec1 = this.pointA.cross3(this.pointB);
		var vec2 = LineB.pointA.cross3(LineB.pointB);
		var vec3 = vec1.cross(vec2); //Vector3 cross
		
		if(vec3.z == 0) return false;
		
		iPoint = new Vector2(vec3.x/vec3.z, vec3.y/vec3.z);
		//console.log("intersect: "+iPoint.log()+" on "+LineB.log());
		//console.log("In x: "+((iPoint.x < LineB.pointA.x) != (iPoint.x < LineB.pointB.x)));
		//console.log("In y: "+((iPoint.y < LineB.pointA.y) != (iPoint.y < LineB.pointB.y)));

		if(LineB.pointA.x == LineB.pointB.x){
			if(!((iPoint.y < LineB.pointA.y) != (iPoint.y < LineB.pointB.y))){
				return false;
			}
		}
		if(LineB.pointA.y == LineB.pointB.y){
			if(!((iPoint.x < LineB.pointA.x) != (iPoint.x < LineB.pointB.x))){
				return false;
			}
		}
		/*if(!((iPoint.x < LineB.pointA.x) != (iPoint.x < LineB.pointB.x) && (iPoint.y < LineB.pointA.y) != (iPoint.y < LineB.pointB.y))){
			return false;																//does not work for vert/horiz lines
		}*/
		
		return iPoint;
	}

	this.log = function() {
		return "("+this.pointA.x.toFixed(2)+","+this.pointA.y.toFixed(2)+"),("+this.pointB.x.toFixed(2)+","+this.pointB.y.toFixed(2)+")";
	}
}

function Ball() {
	this.position = new Vector2(gWidth/2, gHeight/2);
	this.velocity = new Vector2(Math.random()*4-2,Math.random()*4-2).addMag(1);

	this.glow = 0;
}

function Paddle() {
	this.position = new Vector2(80, gHeight / 2)
	this.velocity = new Vector2(0,0);
}

function AI(name,color,attention,accuracy,confidence,animation) {
	this.name = name;
	this.color = color;
	this.attention = attention;	//How soon the AI starts predicting the path
	this.accuracy = accuracy;	//After calculating path, the range the AI might guess the path will go
	this.confidence = confidence;	//How far from the guessed point the AI wants to be
	this.animation = animation;	//How much the AI tends to move

	this.idleRange = null;
	this.idleDir = false;
	this.idleNum = 0;
	this.guess = null;
	this.guessRange = null;
}

///////////////////////////////////////////////////////////////////////////
//                                 Input                                 //
///////////////////////////////////////////////////////////////////////////

function kDown(event) {
	if(!ai && event.key == "ArrowLeft") {
		left2 = true;
		return
	}
	if(!ai && event.key == "ArrowUp") {
		up2 = true;
		return
	}
	if(!ai && event.key == "ArrowRight") {
		right2 = true;
		return
	}
	if(!ai && event.key == "ArrowDown") {
		down2 = true;
		return
	}
	if(event.key == "ArrowLeft" || event.key == "a" || event.key == "A") {
		left = true;
		return
	}
	if(event.key == "ArrowUp" || event.key == "w" || event.key == "W") {
		up = true;
		return
	}
	if(event.key == "ArrowRight" || event.key == "d" || event.key == "D") {
		right = true;
		return
	}
	if(event.key == "ArrowDown" || event.key == "s" || event.key == "S") {
		down = true;
		return
	}
	if(game && event.key == " ") {
		pause = !pause;
		if(pause) splash("Paused");
		else sp.style.display = "none";
	}
	if(game && event.key == "m" || event.key == "M") {
		if(mn.style.visibility == "visible") {
		//TODO: make this happen only when not typing in input//
			//mn.style.visibility = "hidden";
			//pause = false;
		} else {
			sp.style.display = "none";
			mn.style.visibility = "visible";
			pause = true;
		}
	}
	if(!game && (event.key == "m" || event.key == "M" || event.key == " ")) {
		sp.style.display = "none";
		mn.style.visibility = "visible";
	}
}

function kUp(event) {
	if(!ai && event.key == "ArrowLeft") {
		left2 = false;
		return
	}
	if(!ai && event.key == "ArrowUp") {
		up2 = false;
		return
	}
	if(!ai && event.key == "ArrowRight") {
		right2 = false;
		return
	}
	if(!ai && event.key == "ArrowDown") {
		down2 = false;
		return
	}
	if(event.key == "ArrowLeft" || event.key == "a" || event.key == "A") {
		left = false;
		return
	}
	if(event.key == "ArrowUp" || event.key == "w" || event.key == "W") {
		up = false;
		return
	}
	if(event.key == "ArrowRight" || event.key == "d" || event.key == "D") {
		right = false;
		return
	}
	if(event.key == "ArrowDown" || event.key == "s" || event.key == "S") {
		down = false;
		return
	}
}

function touchHandle(event) {
	event.preventDefault();

	touch.x = event.touches[0].clientX - pgPos.x
	touch.y = event.touches[0].clientY - pgPos.y;
	test.innerHTML = touch.x+", "+touch.y;

	if(dblTap) pause = !pause;
	dblTap = true;
	setTimeout(function() {dblTap = false;}, 500);
}

///////////////////////////////////////////////////////////////////////////
//                               Intervals                               //
///////////////////////////////////////////////////////////////////////////
		//TODO use delta time//
function update() {
	ctx.clearRect(0,0,gWidth,gHeight);
	if(game && !pause) pausable();

		//VFX on top because I needed ball glow behind ball. Might add second VFX function on top later//
	drawVFX();
	drawStuff();

	window.requestAnimationFrame(update);
}

function pausable() {
	time++;

	if(ai && game) runAI();
	if(touch.x != 0 && touch.y != 0){
		if(touch.y > p1.position.y) {
			up = false;
			down = true;
		}
		if(touch.y < p1.position.y) {
			up = true;
			down = false;
		}
	}

	if(up) {
		p1.velocity = p1.velocity.add(new Vector2(0,-0.15)).limit(3.5);
	}
	if(down) {
		p1.velocity = p1.velocity.add(new Vector2(0,0.15)).limit(3.5);
	}
	if(!up && !down) {
		p1.velocity = p1.velocity.multiply(0.95);
		if(p1.velocity.magnitude() < 0.05) p1.velocity = new Vector2(0,0);
	}
	
	if(up2) {
		p2.velocity = p2.velocity.add(new Vector2(0,-0.15)).limit(3.5);
	}
	if(down2) {
		p2.velocity = p2.velocity.add(new Vector2(0,0.15)).limit(3.5);
	}
	if(!up2 && !down2) {
		p2.velocity = p2.velocity.multiply(0.95);
		if(p2.velocity.magnitude() < 0.05) p2.velocity = new Vector2(0,0);
	}

	checkCollisions();

	p1.position = p1.position.add(p1.velocity);
	p1.position.y = clamp(p1.position.y,112,gHeight-25);
	p2.position = p2.position.add(p2.velocity);
	p2.position.y = clamp(p2.position.y,112,gHeight-25);
	ball.position = ball.position.add(ball.velocity);
}

///////////////////////////////////////////////////////////////////////////
//                               Collisions                              //
///////////////////////////////////////////////////////////////////////////

		//TODO: SFX//
function checkCollisions() {
		//Check paddle collisions//
		//TODO: When ball is angled just right, the rotator rotates the ball towards the wall after bouncing.//
		//Game breaking for win="bounces"//
	if((ball.position.x <= p1.position.x + 5 && ball.position.x > p1.position.x && ball.position.y < p1.position.y + 25 && ball.position.y > p1.position.y -25) || 
	   (ball.position.x >= p2.position.x - 5 && ball.position.x < p2.position.x && ball.position.y < p2.position.y + 25 && ball.position.y > p2.position.y -25)) {
		ball.velocity = ball.velocity.hadamard(new Vector2(-1,1));
		if(ball.velocity.x > 0) {
			var slope = -(ball.position.y - p1.position.y) / 5;
			ball.velocity = ball.velocity.rotate(Math.atan(slope ** -1)/2);
			if(right) ball.velocity = ball.velocity.add(new Vector2(0.5,0));
			ballColor = p1Color;
		}
		if(ball.velocity.x < 0) {
			var slope = (ball.position.y - p2.position.y) / 5;
			ball.velocity = ball.velocity.rotate(Math.atan(slope ** -1)/2);
			if(left2) ball.velocity = ball.velocity.add(new Vector2(-0.5,0));
			ballColor = p2Color;
		}
		ballColor2 = colorToRGB(ballColor);
		ball.position.x = clamp(ball.position.x, p1.position.x + 5, p2.position.x - 5);

		ball.glow = ball.velocity.magnitude();
		hits++;
		hit();
		speed();
		projTraj();
	}
		//Check top/bottom collisions//
	if(ball.position.y <= 100 || ball.position.y >= gHeight - 4) {
		ball.position.y = clamp(ball.position.y, 100, gHeight-4);
		ball.velocity = ball.velocity.hadamard(new Vector2(1,-1));
		if((ball.velocity.angle() < Math.PI && ball.velocity.angle() > Math.PI/2) || (ball.velocity.angle() < 0 && ball.velocity.angle() > -Math.PI/2)) {
			ball.velocity = ball.velocity.rotate(Math.PI/32);
		} else {
			ball.velocity = ball.velocity.rotate(-Math.PI/32);
		}
		if(win == "bounces") {
			if(ballColor == p1Color){
				p1Score++;
				score();
			}else if(ballColor == p2Color) {
				p2Score++;
				score();
			}
		}

		ball.glow = ball.velocity.magnitude();
		projTraj();
	}
		//Check right collision//
	if(ball.position.x > gWidth) {
		p1Score++;
		rounds++;
		score();
		goalTarg = new Vector2(ball.position.x, ball.position.y);
		goalColor = ballColor;
		goalGlow = 0;
		if(((win == "points" || win == "bounces") && winCount <= p1Score) || 
		   (win == "rounds" && winCount <= rounds)) {
			gameOver();
			return;
		}
		hits = 0;
		hit();

		ball = new Ball();
		speed();
		projTraj();
	}
		//Check left collision//
	if(ball.position.x < 0) {
		p2Score++;
		rounds++;
		score();
		goalTarg = new Vector2(ball.position.x, ball.position.y);
		goalColor = ballColor;
		goalGlow = 0;
		if(((win == "points" || win == "bounces") && winCount <= p2Score) || 
		   (win == "rounds" && winCount <= rounds)) {
			gameOver();
			return;
		}
		hits = 0;
		hit();

		ball = new Ball();
		speed();
		projTraj();
	}
}

///////////////////////////////////////////////////////////////////////////
//                                   AI                                  //
///////////////////////////////////////////////////////////////////////////

function runAI() {
		//Periodically check where the ball will go//
	if(ball.velocity.x > 0 && time % 50 == 0) {
		projTraj();
	}
		//Periodically switch animations//
	if(time % 737 == 0) {
		pai.idleNum = Math.floor(Math.random()*4);
	}

	down2 = false;
	up2 = false;
	if(pai.guess) {	//Get ready for the ball//
		pai.idleRange = null;
		if(p2.position.y < pai.goalRange.a) {
			down2 = true;
			up2 = false;
		}
		if(p2.position.y > pai.goalRange.b) {
			down2 = false;
			up2 = true;
		}
	} else {	//Animate//
		//Animation target location//
		if(time % 150 == 0) {
			var idleTarget = Math.random() * (gHeight - 92) + 92;
			var mod = Math.random() * 50;
			pai.idleRange = new Range(idleTarget - mod, idleTarget + mod).limit(92, gHeight);
		}
		//Go back and forth across target location//
		if(pai.idleRange && pai.idleNum == 0) {
			if(p2.position.y < ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)) {
				down2 = true;
				up2 = false;
			}
			if(p2.position.y > ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)) {
				down2 = false;
				up2 = true;
			}
			if(p2.position.y < ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)+10 && p2.position.y > ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)-10) {
				pai.idleDir = !pai.idleDir;
			}
		}
		//Nudge back and forth across target location//
		if(pai.idleRange && pai.idleNum == 1) {
			if(p2.position.y < ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)) {
				if(time % 150 < 20) {
					down2 = true;
					up2 = false;
				}
			}
			if(p2.position.y > ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)) {
				if(time % 150 < 20) {
					down2 = false;
					up2 = true;
				}
			}
			if(p2.position.y < ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)+10 && p2.position.y > ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)-10) {
				pai.idleDir = !pai.idleDir;
			}
		}
		//Track ball//
		if(pai.idleNum == 2) {
			if(p2.position.y < ball.position.y) {
				down2 = true;
				up2 = false;
			}
			if(p2.position.y > ball.position.y) {
				down2 = false;
				up2 = true;
			}
		}
		//Track opponent//
		if(pai.idleNum == 3) {
			if(p2.position.y < p1.position.y - 25) {
				down2 = true;
				up2 = false;
			}
			if(p2.position.y > p1.position.y + 25) {
				down2 = false;
				up2 = true;
			}
		}
	}
}

function projTraj() {
	if(ai) pai.guess = null;
	goal = null;

	var tl = new Vector2(p1.position.x+5, 92);
	var tr = new Vector2(p2.position.x-5, 92);
	var br = new Vector2(p2.position.x-5, gHeight);
	var bl = new Vector2(p1.position.x+5, gHeight);
	var top = new Line(tl, tr);
	var right = new Line(tr, br);
	var bottom = new Line(br, bl);
	var left = new Line(bl, tl);

	hitPoints = [];
	var traj = new Line(ball.position, ball.position.add(ball.velocity));
	var trajVel = new Vector2(ball.velocity.x, ball.velocity.y);
		//Collect the points where the ball should hit the wall sequentially//
	for(i=0;i<3;i++){
		if(trajVel.x > 0) {
			if(traj.intersect(right)){
				hitPoints[hitPoints.length]=traj.intersect(right);
				trajVel = trajVel.hadamard(new Vector2(-1,1));
				if(!goal) goal = hitPoints[hitPoints.length-1];
				
				let index = i;
				if (ai) guessHit(hitPoints[hitPoints.length-1], index);
			}
		} else if(trajVel.x < 0) {
			if(traj.intersect(left)){
				hitPoints[hitPoints.length]=traj.intersect(left);
				trajVel = trajVel.hadamard(new Vector2(-1,1));
				if(!goal) goal = hitPoints[hitPoints.length-1];
			}
		}
		if(trajVel.y > 0) {
			if(traj.intersect(bottom)){
				hitPoints[hitPoints.length]=traj.intersect(bottom);
				trajVel = trajVel.hadamard(new Vector2(1,-1));
			}
		} else if(trajVel.y < 0) {
			if(traj.intersect(top)){
				hitPoints[hitPoints.length]=traj.intersect(top);
				trajVel = trajVel.hadamard(new Vector2(1,-1));
			}
		}
		
		if(hitPoints.length == 0) return;
		traj = new Line(hitPoints[hitPoints.length-1], hitPoints[hitPoints.length-1].add(trajVel));
	}
}

		//The illusion of human error//
function guessHit(project, index) {
	if(!pai.guess) {
		var distance = (p2.position.x - ball.position.x + ((ball.velocity.x < 0) ? (ball.position.x - p1.position.x) * 2 : 0)) / 20;
		var mod = (1+index) * distance / pai.accuracy;
		pai.guessRange = new Range(project.y - mod, project.y + mod).limit(92, gHeight);
		pai.guess = new Vector2(project.x, pai.guessRange.random());
		pai.goalRange = new Range(pai.guess.y - (distance / pai.confidence), pai.guess.y + (distance / pai.confidence)).limit(92, gHeight);
	}
}

///////////////////////////////////////////////////////////////////////////
//                                Drawing                                //
///////////////////////////////////////////////////////////////////////////

function drawStuff() {
	ctx.strokeStyle = "#FFFFFF";
	ctx.lineWidth = 1;
	ctx.fillStyle = "#FFFFFF";

	ctx.beginPath();
	ctx.fillStyle = ballColor;
	ctx.arc(ball.position.x,ball.position.y,8,0,Math.PI * 2,true);
	ctx.fill();

	ctx.beginPath();
	ctx.fillStyle = p1Color;
	ctx.fillRect(p1.position.x-5,p1.position.y-25,10,50);
	ctx.beginPath();
	ctx.fillStyle = p2Color;
	ctx.fillRect(p2.position.x-5,p2.position.y-25,10,50);

	if(showAI) {
		if(showBallPath) {
			ctx.beginPath();
			ctx.strokeStyle = "#FF0000";
			ctx.lineWidth = 3;
			var trajDraw = ball.position;
			for(i=0;i<hitPoints.length;i++) {
				ctx.moveTo(trajDraw.x,trajDraw.y);
				ctx.lineTo(hitPoints[i].x,hitPoints[i].y);
				ctx.stroke();
				trajDraw = hitPoints[i];
			}
		}
		if(showGoalHit && goal != null) {
			ctx.beginPath();
			ctx.strokeStyle = "#FF0000";
			ctx.lineWidth = 1;
			ctx.arc(goal.x,goal.y,8,0,Math.PI*2,true);
			ctx.stroke();
		}
		if(ai && showGoalGuess && pai.guess !=null) {
			ctx.beginPath();
			ctx.strokeStyle = "#0000FF";
			ctx.lineWidth = 1;
			ctx.arc(pai.guess.x,pai.guess.y,8,0,Math.PI*2,true);
			ctx.stroke();
		}
		if(ai && showGuessRange && pai.guess != null) {
			ctx.beginPath();
			ctx.strokeStyle = "#0000FF";
			ctx.lineWidth = 2;
			ctx.moveTo(pai.guess.x-5, pai.guessRange.a);
			ctx.lineTo(pai.guess.x+5, pai.guessRange.a);
			ctx.moveTo(pai.guess.x-5, pai.guessRange.b);
			ctx.lineTo(pai.guess.x+5, pai.guessRange.b);
			ctx.stroke();
		}
		if(ai && showGoalRange && pai.guess) {
			ctx.beginPath();
			ctx.strokeStyle = "#FFFF00";
			ctx.lineWidth = 3;
			ctx.moveTo(p2.position.x, pai.goalRange.a);
			ctx.lineTo(p2.position.x, pai.goalRange.b);
			ctx.stroke();
		}
	}
}

function drawVFX() {
	if(ball.glow > 0) {
		ctx.beginPath();
		gradient = ctx.createRadialGradient(ball.position.x, ball.position.y, 5, ball.position.x, ball.position.y, 5+(ball.glow*4));
		gradient.addColorStop(0.1,`rgba(${ballColor2.join(",")},1)`);
		gradient.addColorStop(0.8,`rgba(${ballColor2.join(",")},0.3)`);
		//gradient.addColorStop(0.9,`rgba(${ballColor2.join(",")},0`);
		ctx.fillStyle = gradient;
		ctx.arc(ball.position.x,ball.position.y,5+(ball.glow*4),0,Math.PI*2);
		ctx.fill();
		ball.glow -= 0.1;
		if(ball.glow < 0) ball.glow = 0;
	}
	if(goalTarg) {
		ctx.beginPath();
		gradient = ctx.createRadialGradient(goalTarg.x, goalTarg.y, 1, goalTarg.x, goalTarg.y, goalGlow);
		var goalColor2 = colorToRGB(goalColor);
		gradient.addColorStop(0.1,`rgba(${goalColor2.join(",")},0.9)`);
		gradient.addColorStop(0.9,`rgba(${goalColor2.join(",")},0.2)`);
		ctx.fillStyle = gradient;
		ctx.arc(goalTarg.x, goalTarg.y, goalGlow, 0, Math.PI*2);
		ctx.fill();
		goalGlow+=10;
		if(goalGlow > 200) {
			goalTarg = null;
		}
	}
}

///////////////////////////////////////////////////////////////////////////
//                                Utility                                //
///////////////////////////////////////////////////////////////////////////

function clamp(value, min, max) {
	return Math.min(Math.max(value, min), max);
}

	//Returns -1 or 1 if the value isn't 0//
function sign(value) {
	if(!value) return 0;
	return value / Math.abs(value)
}

function checkColors() {
	var s = new Option().style;
	s.color = p1Color;
	if(s.color == "") p1Color = "white";
	s.color = null;
	s.color = p2Color;
	if(s.color == "") p2Color = "white";
}

function colorToRGB(string) {
	ctx.beginPath();
	ctx.fillStyle = string;
	ctx.fillRect(0,0,1,1);
	var pixel = ctx.getImageData(0,0,1,1).data;
	return [pixel[0],pixel[1],pixel[2]];
}

//-----------------------------------------------------------------------//
		</script>
	</head>
	<body onload="loadStuff()" onkeydown="kDown(event)" onkeyup="kUp(event)">
		<h1>Pung</h1>
		<canvas id="playground"></canvas>
		<div id="status">
			<div id="scorediv" style="margin-left: 1px">
				<span id="p1">Player 1</span>: <span id="p1score"></span><br />
				<span id="p2">CPU</span>: <span id="p2score"></span>
			</div>
			<div id="hitsdiv">
				Hits this round: <span id="hits"></span><br>
				Most hits: <span id="hitsmax"></span>
			</div>
			<div id="ballspeeddiv">
				Ball speed: <span id="speed"></span><br>
				Highest speed: <span id="speedmax"></span>
			</div>
			<div id="testdiv">

			</div>
		</div>
		<div id="menu">
			<h2>Menu</h2>
			<div id="left" class="half">
				<h3>Game Settings</h3>
				<div class="margin">
					<hr /><br />
					Player 1 Name: <input id="name-p1" type="text" value="Player 1" />
					Color: <input id="color-p1" type="text" value="white" /><br /><br /><br />
					<hr /><br />
					<strong>Win by:</strong> <br />
					<label for="win-rounds">Rounds? <input id="win-rounds" type="radio" name="win" value="rounds" /></label>
					Number: <input id="count-rounds" type="number" value=20 /><br />
					<label for="win-points">Points? <input id="win-points" type="radio" name="win" value="points" checked /></label>
					Number: <input id="count-points" type="number" value=10 /><br />
					<label for="win-bounces">Bounces? <input id="win-bounces" type="radio" name="win" value="bounces" /></label>
					Number: <input id="count-bounces" type="number" value=50 /><br />
					<label for="win-never">Never? <input id="win-never" type="radio" name="win" value="never" /></label>
				</div>
			</div>
			<div id="right" class="half">
				<h3>Player 2</h3>
				<div class="margin">
					<hr /><br />
					<label for="player-human">Human? <input id="player-human" type="radio" name="player" value="human" /></label>
					Name: <input id="name-p2" type="text" value="Player 2" /> 
					Color: <input id="color-p2" type="text" value="white" /><br />
					<label for="player-ai">AI? <input id="player-ai" type="radio" name="player" value="ai" checked /></label>
					Model: <select id="name-ai">
						<option value=0>Lenny</option>
						<option value=1>Martha</option>
					</select><br /><br />
					<hr /><br />
		<!--TODO: Add model builder functionality-->
		<!--TODO: Add the ability to toggle AI visualizations-->
					<button>Add AI Model</button>
				</div>
			</div>
			<button id="newgame" onclick="newGame()">New Game</button>
		</div>
		<div id="splash"></div>
	</body>
</html>