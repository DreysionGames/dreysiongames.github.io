<!DOCTYPE html>
<html>
<!--
Code by Dreysion, with some help from StackOverflow and ChatGPT of course
Done on basic Notepad to prove I can :p
First time implementing my own Vector math, not built into a game engine!
My coding practices have improved since I started working on this, so some updates might have different styles.
-->
	<head>
		<title>Pung</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<style>
* {
	margin: 0;
	padding: 0;
	/*box-sizing: border-box;*/

	overscroll-behavior: contain;	/*prevent touch refresh*/
	touch-action: manipulation;	/*prevent touch zoom*/
	user-select: none;		/*prevent touch text select*/
}

h1 {
	position: absolute;
	text-align: center;
	font-size: 48px;
	width: 100%;
}

h2, h3 {
	margin: 20px;
	text-align: center;
}

body {
	background-color: #454556;
}

canvas {
	/*margin-top: 50px;*/
	border: 1px solid #000000;
	background-color: #000000;
} 

#status {
	position: relative;
	height: 80px;
	opacity: 0.6;
}

#status:hover {
	opacity: 0.9;
}

#status div {
	position: absolute;
	min-height: 80px;
	border: 1px solid #FFFFFF;
	padding: 20px;
	color: #FFFFFF;
	overflow: hidden;
	white-space: nowrap;
	box-sizing: border-box;
}

#status div span::before {
	content: var(--prefix);
}

#menu {
	position: absolute;
	border: 1px solid #000000;
	background-color: #676778;
}

#newgame {
	position: absolute;
	bottom: 20px;
	left: 50%;
	transform: translate(-50%,0);
}

.half {
	position: absolute;
	border: 1px solid #000000;
	overflow-y: scroll;
}

.margin {
	margin-left: 40px;
	margin-right: 40px;
}

.tab {
	position: absolute;
	display: inline-block;
	width: calc(50% - 51px);
	padding: 5px;
	background-color: #565667;
	border: 1px solid #000000;
	text-align: center;
}

.selected {
	background-color: #454556;
}

.tab-content {
	/*width: 100%;*/
	height: 100%;
	padding: 10px;
	border: 1px solid #000000;
}

.tab-content label {
	margin-left: 50px;
	text-align: left;
}

label {
	display: inline-block;
	min-width: 100px;
	text-align: right;
}

.disabled {
	opacity: 0.7;
}

input[type="text"] {
	width: 80px;
}

input[type="number"] {
	width: 40px;
}

#splash {
	position: absolute;
	left: 0px;
	width: 100%;
	text-align: center;
	display: none;
}

#splash-title {
	display: block;
	padding-top: 40px;
	padding-bottom: 40px;
	width: 100%;
	font-size: 60px;
	background-color: #686868;
	color: #FFFFFF;
	border-top: 5px solid #FFFFFF;
	border-bottom: 5px solid #FFFFFF;
	opacity: 0.4;
}

::-webkit-scrollbar {
	width: 10px;
}



::-webkit-scrollbar-thumb {
	background: #121223;
	border-radius: 5px;
}
		</style>
		<script>
//-----------------------------------------------------------------------//


///////////////////////////////////////////////////////////////////////////
//                                 Setup                                 //
///////////////////////////////////////////////////////////////////////////

var Scale = new Vector2(0,0);
var SMag = 0;
var topPos;
var pg;
var st;
var test;
var mn;
var sp;
var sptit;
var ctx;
var gWidth = 0;
var gHeight = 0;

var win;
var winCount;
var rounds = 0;
var ai = true;
var p1;
var p2;
var pai;
var ball;

var playPromise;

var hitPoints = [];
var AIModels = [	//name,color,attention,accuracy,urgency,aggression,animation//
	new AI("Lenny","yellow",0.7,0.9,1,1,0.2),
	new AI("Martha","magenta",0.9,0.6,0.2,0,1),
	new AI("Barry","indigo",0.3,0.5,0.6,0.6,0.7),
	new AI("Helga","brown",0.8,0.4,0.6,1,0.4),
	new AI("Sam","orange",0.5,0.7,0.3,0.7,0.8)
];

//helpful visualizations
var showAI = false;
var showBallPath = true;
var showGoalHit = true;
var showGuessRange = true;
var showGoalGuess = true;
var showGoalRange = true;

var p1Score = 0;
var p2Score = 0;
var p1Name = "Player 1";
var p2Name = "Player 2";
var p1Color = "white";
var p2Color = "white";
var ballColor = "white";
var ballColor2 = [255,255,255];
var hits = 0;
var hitsMax = 0;
var velocity = 0;
var velMax = 0;

var touch = new Vector2(0,0);
var dblTap = false;

var left = false;
var up = false;
var right = false;
var down = false;
var left2 = false;
var up2 = false;
var right2 = false;
var down2 = false;

var time = 0;
var lastTick = Date.now()
var game = false;
var pause = true;

var goal;
var goalTarg;
var goalColor = "white";
var goalGlow = 0;
			//TODO: intro/key hints//
function loadStuff(){
	var w = window.innerWidth - 40;
	var h = window.innerHeight - 240;
	gWidth = (w > h * 5/3) ? h * 5/3 : w;
	gHeight = (w > h * 5/3) ? h : w * 3/5;

	
	pg = new Box(document.getElementById("playground"), 0, 0, 1, 1);
	mn = new Box(document.getElementById("menu"), 0, 0, 1, 1);
	st = new Box(document.getElementById("status"), 0, 0, 1, 0.1);
	test = document.getElementById("testdiv");
	sp = document.getElementById("splash");
	sptit = document.getElementById("splash-title");

	ctx = pg.element.getContext("2d", {willReadFrequently: true});

	p1 = new Paddle();
	p2 = new Paddle();
	ball = new Ball();
	layout();

	window.addEventListener('resize', layout);
	window.addEventListener('touchmove', (e) => {touchHandle(e)});
	window.addEventListener('touchstart', (e) => {touchHandle(e)});
	window.addEventListener('touchend', (e) => {
		if(e.touches.length == 0) {
			touch.x = 0;
			touch.y = 0;
			up = false;
			down = false;
		}
	});
	screen.addEventListener("orientationchange", () => {
		layout();
	});

	Music = new Audio("PungMus.mp3");
	Music.loop = true;
	sfxBump = new Audio("pah-various.ogg");

	window.requestAnimationFrame(update);
}

function layout(){
	var w = window.innerWidth;
	var h = window.innerHeight;
	var hr = h/window.devicePixelRatio;

	var bb = (hr > 500) ? 40 : (hr > 300) ? 20 : 10;
	var bt = (hr > 500) ? 48 : 36;
	topPos = (2*bb)+bt;
	var viewHeight = h - bt - (3*bb);
	var viewWidth = w - 80;

	Scale.x = ((viewWidth > viewHeight * 5/3) ? viewHeight * 5/3 : viewWidth);
	Scale.y = ((viewWidth > viewHeight * 5/3) ? viewHeight : viewWidth * 3/5);
	
	SMag = Scale.magnitude() / 1350;
	gWidth = Scale.x;
	gHeight = Scale.y;

	document.getElementById("title").style.top = bb + "px";
	document.getElementById("title").style.fontSize = bt + "px";
	document.body.style.fontSize = (hr > 500) ? "17px" : "10px";
	pg.setBox(0,0,1,1);
	mn.setBox(0,0,1,1);
	st.setBox(0,0,1,0.1);
	for (i=0; i<st.element.children.length; i++) {
		st.element.children[i].style.left = i * Scale.x / 4 + "px";
		st.element.children[i].style.width = Scale.x / 4 + "px";
		st.element.children[i].style.height = Scale.y / 9 + "px";
	}
	if(st.element.children[0].clientWidth > 85) {
		document.getElementById("p1score").style.setProperty('--prefix', "'" + p1Name + ": '");
		document.getElementById("p2score").style.setProperty('--prefix', "'" + p2Name + ": '");
	} else {
		document.getElementById("p1score").style.setProperty('--prefix', "''");
		document.getElementById("p2score").style.setProperty('--prefix', "''");
	}
	if(st.element.children[0].clientWidth > 150) {
		document.getElementById("hits").style.setProperty('--prefix', "'Hits this round: '");
		document.getElementById("hitsmax").style.setProperty('--prefix', "'Most hits: '");
		document.getElementById("speed").style.setProperty('--prefix', "'Speed this round: '");
		document.getElementById("speedmax").style.setProperty('--prefix', "'Highest speed: '");
	} else {
		document.getElementById("hits").style.setProperty('--prefix', "''");
		document.getElementById("hitsmax").style.setProperty('--prefix', "''");
		document.getElementById("speed").style.setProperty('--prefix', "''");
		document.getElementById("speedmax").style.setProperty('--prefix', "''");
	}
	document.getElementById("vis-div").style.width = document.getElementsByClassName("margin")[1].style.width;
	document.getElementById("mod-div").style.width = document.getElementsByClassName("margin")[1].style.width;
	sp.style.top = window.innerHeight / 2 - 75 + "px";

	for(var div in document.getElementsByClassName("half")) {
		if(!isNaN(div)) {
			document.getElementsByClassName("half")[div].style.width = gWidth / 2 - 4 + "px";
			document.getElementsByClassName("half")[div].style.height = gHeight - 120 + "px";
		}
	}
	document.getElementById("right").style.right = "0px";

	p1.position.x = 80*SMag;
	p1.position.y = SMag*p1.position.y/p1.savedScale;
	p1.savedScale = SMag;
	p2.position.x = gWidth-(80*SMag);
	p2.position.y = SMag*p2.position.y/p2.savedScale;
	p2.savedScale = SMag;
	ball.position = ball.position.multiply(SMag / ball.savedScale);
	ball.savedScale = SMag;

	projTraj();

	pgPos = new Vector2(pg.element.getBoundingClientRect().x, pg.element.getBoundingClientRect().y);
}

function newGame() {
	ai = document.getElementById("player-ai").checked;
	p1Name = document.getElementById("name-p1").value;
	p1Color = document.getElementById("color-p1").value;
	if(ai) {
		pai = AIModels[document.getElementById("name-ai").value];
		p2Name = pai.name;
		p2Color = pai.color;
		
	} else {
		p2Name = document.getElementById("name-p2").value;
		p2Color = document.getElementById("color-p2").value;
	}
	checkColors();
	document.getElementById("p1score").style.setProperty('--prefix', "'" + p1Name + ": '");
	document.getElementById("p2score").style.setProperty('--prefix', "'" + p2Name + ": '");
	if(document.getElementById("win-rounds").checked) win = "rounds";
	else if(document.getElementById("win-points").checked) win = "points";
	else if(document.getElementById("win-bounces").checked) win = "bounces";
	else win = "never";

	showAI = document.getElementById("ai-visuals").checked;
	showBallPath = document.getElementById("ai-ball-path").checked;
	showGoalHit = document.getElementById("ai-goal-hit").checked;
	showGuessRange = document.getElementById("ai-guess-range").checked;
	showGoalGuess = document.getElementById("ai-goal-guess").checked;
	showGoalRange = document.getElementById("ai-goal-range").checked;

	if(win == "rounds") {
		winCount = document.getElementById("count-rounds").value;
	} else if(win == "points") {
		winCount = document.getElementById("count-points").value;
	} else if(win == "bounces") {
		winCount = document.getElementById("count-bounces").value;
	}
	if(!winCount) win = "never";

	p1Score = 0;
	p2Score = 0;
	hitsMax = 0;
	velMax = 0;

	p1.position.y = gHeight / 2;
	p2.position.y = gHeight / 2;
	ball = new Ball();
	ball.color = "white";

	mn.element.style.visibility = "hidden";
	pause = false;

	score();
	hit();
	speed();
	projTraj();

	Music.currentTime = 0;
	Music.play();

	game = true;
}

function gameOver() {
	pause = true;
	game = false;

	if(p1Score > p2Score) {
		splash(p1Name + " wins!");
	} else if(p2Score > p1Score) {
		splash(p2Name + " wins!");
	} else {
		splash("Draw!");
	}
}

function score() {
	document.getElementById("p1score").innerHTML = p1Score;
	document.getElementById("p2score").innerHTML = p2Score;
}

function hit() {
	if(hits > hitsMax) hitsMax = hits;
	document.getElementById("hits").innerHTML = hits;
	document.getElementById("hitsmax").innerHTML = hitsMax;
}

function speed() {
	if(ball.velocity.magnitude().toFixed(2) > velMax) velMax = ball.velocity.magnitude().toFixed(2);
	document.getElementById("speed").innerHTML = ball.velocity.magnitude().toFixed(2);
	document.getElementById("speedmax").innerHTML = velMax;
}

function splash(text) {
	sptit.innerHTML = text;
	sp.style.display = "block";
}

function menu() {
	if(mn.element.style.visibility == "visible") {
		mn.element.style.visibility = "hidden";
		pause = false;
		Music.play();
	} else {
		sp.style.display = "none";
		mn.element.style.visibility = "visible";
		pause = true;
		Music.pause();
	}
}

function toggleTab(which) {
	document.getElementById("mod-tab").classList.remove("selected");
	document.getElementById("vis-tab").classList.remove("selected");
	document.getElementById("mod-div").style.display = "none";
	document.getElementById("vis-div").style.display = "none";

	document.getElementById(which+"-tab").classList.add("selected");
	document.getElementById(which+"-div").style.display = "block";
}

function addModel() {
	AIModels[AIModels.length] = new AI(
		document.getElementById("ai-name").value,
		document.getElementById("ai-color").value,
		document.getElementById("ai-attention").value,
		document.getElementById("ai-accuracy").value,
		document.getElementById("ai-urgency").value,
		document.getElementById("ai-aggression").value,
		document.getElementById("ai-animation").value
	);

	var opt = document.createElement("option");
	opt.value = AIModels.length - 1;
	opt.innerHTML = AIModels[AIModels.length - 1].name;
	document.getElementById("name-ai").appendChild(opt);

	document.getElementById("ai-name").value="";
	document.getElementById("ai-color").value="";
	document.getElementById("ai-attention").value="";
	document.getElementById("ai-accuracy").value="";
	document.getElementById("ai-urgency").value="";
	document.getElementById("ai-aggression").value="";
	document.getElementById("ai-animation").value="";
}

function checkVis() {
	visChecked = document.getElementById("ai-visuals").checked;

	labels = document.getElementsByTagName('label');
	for(var c in document.getElementsByClassName("vis-check")) {
		for(i=0; i<labels.length; i++) {
			if(labels[i].htmlFor == document.getElementsByClassName("vis-check")[c].id) {
				visChecked ? labels[i].classList.remove("disabled") : labels[i].classList.add("disabled");
			}
		}
		document.getElementsByClassName("vis-check")[c].disabled = !visChecked;
	}
}

function playBump(time) {
	if(!sfxBump.paused) {
		if(playPromise !== undefined) {
			playPromise.then(_ => {
				
			})
			.catch(error => {console.log("error")});
		}
		sfxBump.pause();
	}
	if(time < 0) var sfxRng = Math.floor(Math.random()*10)/2;
	else var sfxRng = time;
	sfxBump.currentTime = sfxRng;
	playPromise = sfxBump.play();
	setTimeout(() => {
		sfxBump.pause();
	}, 250);
}

///////////////////////////////////////////////////////////////////////////
//                                Objects                                //
///////////////////////////////////////////////////////////////////////////

function Range(a, b) {
	this.a = a;
	this.b = b;
	this.min = Math.min(a,b);
	this.max = Math.max(a,b);
	this.length = this.max - this.min;
	
	this.limit = function(min, max) {
		return new Range(Math.max(this.a, min), Math.min(this.b, max));
	}
	this.random = function(){
		return Math.random() * this.length + this.min;
	}
	this.inRange = function(pos, length){
		return (pos - length / 2 < this.max) && (pos + length / 2 > this.min);
	}
	this.log = function(){
		console.log("("+this.min + ", " + this.max + ")");
	}
}

function Vector2(x, y) {
	this.x = x;
	this.y = y;
	this.angle = function() {
		return Math.atan2(this.y, this.x);
	}
	this.magnitude = function() {
		return Math.sqrt((this.x * this.x) + (this.y * this.y));
	}
	this.normalized = function() {
		return new Vector2(this.x / this.magnitude(), this.y / this.magnitude());
	}

	this.subtract = function(VectorB) {
		return new Vector2(this.x - VectorB.x, this.y - VectorB.y);
	}
	this.add = function(VectorB) {
		return new Vector2(this.x + VectorB.x, this.y + VectorB.y);
	}
	this.addMag = function(value) {
		var newMag = this.magnitude() + value;
		var scale = newMag / this.magnitude();
		return new Vector2(this.x * scale, this.y * scale);
	}
	this.multiply = function(value) {
		return new Vector2(this.x * value, this.y * value);
	}
	this.divide = function(value) {
		return new Vector2(this.x / value, this.y / value);
	}
	this.cross = function(VectorB) {
		return (this.x * VectorB.y) - (this.y * VectorB.x);
	}
	this.cross3 = function(VectorB) {
		var x = this.y * 1 - 1 * VectorB.y;
		var y = 1 * VectorB.x - this.x * 1;
		var z = this.x * VectorB.y - this.y * VectorB.x;
		return new Vector3(x,y,z);
	}
	this.dot = function(VectorB) {
		return this.x * VectorB.x + this.y * VectorB.y;
	}
	this.hadamard = function(VectorB) {
		return new Vector2(this.x * VectorB.x, this.y * VectorB.y);
	}

	this.limit = function(magnitude) {
		if(this.magnitude() <= magnitude){
			return this;
		}
		var unit = this.divide(this.magnitude());
		return unit.multiply(magnitude);
	}
	this.clamp = function(minMag, maxMag) {
		if(this.magnitude() <= maxMag && this.magnitude() >= minMag) return this;
		var unit = this.divide(this.magnitude());
		if(this.magnitude() < minMag) return unit.multiply(minMag);
		if(this.magnitude() > maxMag) return unit.multiply(maxMag);
	}
	this.rotate = function(angle) {
		newAngle = this.angle() + angle;
		return new Vector2(this.magnitude() * Math.cos(newAngle), this.magnitude() * Math.sin(newAngle));
	}

	this.log = function() {
		return "("+this.x.toFixed(2)+", "+this.y.toFixed(2)+")";
	}
}

function Vector3(x, y, z) {
	this.x = x;
	this.y = y;
	this.z = z;

	this.cross = function(VectorB) {
		var x = this.y * VectorB.z - this.z * VectorB.y;
		var y = this.z * VectorB.x - this.x * VectorB.z;
		var z = this.x * VectorB.y - this.y * VectorB.x;
		return new Vector3(x,y,z);
	}
}

function Line(pointA, pointB) { //pointB must be vertical or horizontal
	this.pointA = pointA;
	this.pointB = pointB;
	this.length = Math.sqrt((this.pointB.x - this.pointA.x) * (this.pointB.x - this.pointA.x) + (this.pointB.y - this.pointA.y) * (this.pointB.y - this.pointA.y));
	this.center = new Vector2((this.pointA.x + this.pointB.x) / 2, (this.pointA.y + this.pointB.y) / 2);

	this.localVector = this.pointB.subtract(this.pointA).normalized();

	this.intersect = function(LineB) {
		var vec1 = this.pointA.cross3(this.pointB);
		var vec2 = LineB.pointA.cross3(LineB.pointB);
		var vec3 = vec1.cross(vec2); //Vector3 cross
		
		if(vec3.z == 0) return false;
		
		iPoint = new Vector2(vec3.x/vec3.z, vec3.y/vec3.z);

		if(LineB.pointA.x == LineB.pointB.x){
			if(!((iPoint.y < LineB.pointA.y) != (iPoint.y < LineB.pointB.y))){
				return false;
			}
		}
		if(LineB.pointA.y == LineB.pointB.y){
			if(!((iPoint.x < LineB.pointA.x) != (iPoint.x < LineB.pointB.x))){
				return false;
			}
		}
		
		return iPoint;
	}

	this.log = function() {
		return "("+this.pointA.x.toFixed(2)+","+this.pointA.y.toFixed(2)+"),("+this.pointB.x.toFixed(2)+","+this.pointB.y.toFixed(2)+")";
	}
}

//Was playing with this in another of my projects, let's see if I can incorporate it here
function Box(e, l, t, w, h) {
	this.element = e;
	let left = l;
	let top = t;
	let width = w;
	let height = h;

	this.setBox = function(l,t,w,h) {
		left = l;
		top = t;
		width = w;
		height = h;

		this.setElement();
	};
	this.setElement = function() {
		this.element.style.left = (left * Scale.x) + ((window.innerWidth - 80 - Scale.x)/2) + 40 + "px";
		this.element.style.top = (top * Scale.y) + topPos + "px";
		if(this.element.nodeName == "CANVAS") {
			this.element.width = (width * Scale.x);
			this.element.height = (height * Scale.y);
		} else {
			this.element.style.width = (width * Scale.x) + "px";
			this.element.style.height = (height * Scale.y) + "px";
		}
	};
	this.getSize = function() {
		return new Vector2(width, height);
	};

	this.element.style.display = "block";
	this.element.style.position = "absolute";
	this.setElement();
}

function Ball() {
	this.position = new Vector2(gWidth/2, gHeight/2);
	this.velocity = new Vector2(Math.random()*0.5-0.25,Math.random()*0.5-0.25).addMag(0.25);

	this.savedScale = SMag;

	this.glow = 0;

	this.getRadius = function() {
		return 8 * this.savedScale;
	}
}

function Paddle() {
	this.position = new Vector2(80*SMag, gHeight / 2)
	this.velocity = new Vector2(0,0);

	this.savedScale = SMag;

	this.getWidth = function() {
		return 10 * this.savedScale;
	}
	this.getHeight = function() {
		return 50 * this.savedScale;
	}
}

function AI(name,color,attention,accuracy,urgency,aggression,animation) {
	this.name = name;
	this.color = color;
	this.attention = attention;	//How soon the AI starts predicting the path
	this.accuracy = accuracy;	//After calculating path, the range the AI might guess the path will go
	this.urgency = urgency;		//How far from the guessed point the AI wants to be
	this.aggression = aggression;	//How often AI power shoots
	this.animation = animation;	//How much the AI tends to move

	this.idleRange = null;
	this.idleDir = false;
	this.idleNum = 0;
	this.guess = null;
	this.guessRange = null;
}

///////////////////////////////////////////////////////////////////////////
//                                 Input                                 //
///////////////////////////////////////////////////////////////////////////

function kDown(event) {
	if(event.repeat) return;
	if(event.target.nodeName == "INPUT") return;
	if(!ai && event.key == "ArrowLeft") {
		left2 = true;
		return
	}
	if(!ai && event.key == "ArrowUp") {
		up2 = true;
		return
	}
	if(!ai && event.key == "ArrowRight") {
		right2 = true;
		return
	}
	if(!ai && event.key == "ArrowDown") {
		down2 = true;
		return
	}
	if(event.key == "ArrowLeft" || event.key == "a" || event.key == "A") {
		left = true;
		return
	}
	if(event.key == "ArrowUp" || event.key == "w" || event.key == "W") {
		up = true;
		return
	}
	if(event.key == "ArrowRight" || event.key == "d" || event.key == "D") {
		right = true;
		setTimeout(function() {right = false;}, 500);
		return
	}
	if(event.key == "ArrowDown" || event.key == "s" || event.key == "S") {
		down = true;
		return
	}
	if(game && event.key == " ") {
		pause = !pause;
		if(pause) splash("Paused");
		else sp.style.display = "none";
	}
	if(game && event.key == "m" || event.key == "M") {
		menu();
	}
	if(!game && (event.key == "m" || event.key == "M" || event.key == " ")) {
		sp.style.display = "none";
		mn.element.style.visibility = "visible";
	}
}

function kUp(event) {
	if(!ai && event.key == "ArrowLeft") {
		left2 = false;
		return
	}
	if(!ai && event.key == "ArrowUp") {
		up2 = false;
		return
	}
	if(!ai && event.key == "ArrowRight") {
		right2 = false;
		return
	}
	if(!ai && event.key == "ArrowDown") {
		down2 = false;
		return
	}
	if(event.key == "ArrowLeft" || event.key == "a" || event.key == "A") {
		left = false;
		return
	}
	if(event.key == "ArrowUp" || event.key == "w" || event.key == "W") {
		up = false;
		return
	}
	if(event.key == "ArrowRight" || event.key == "d" || event.key == "D") {
		right = false;
		return
	}
	if(event.key == "ArrowDown" || event.key == "s" || event.key == "S") {
		down = false;
		return
	}
}

function touchHandle(event) {
	event.preventDefault();

	touch.x = event.touches[0].clientX - pgPos.x
	touch.y = event.touches[0].clientY - pgPos.y;

	if(event.type == "touchstart" && event.touches.length == 1) {
		if(dblTap) {
			pause = !pause;
			if(pause) splash("Paused");
			else sp.style.display = "none";
		}
		dblTap = true;
		setTimeout(function() {dblTap = false;}, 300);
		setTimeout(function() {right = false;}, 500);
	}
	if(event.type == "touchstart" && event.touches.length > 1) {
		right = true;
	}
}

///////////////////////////////////////////////////////////////////////////
//                               Intervals                               //
///////////////////////////////////////////////////////////////////////////

function update() {
	ctx.clearRect(0,0,gWidth,gHeight);
	var curTick = Date.now();
	var dt = curTick - lastTick;

	if(game && !pause) pausable(dt);

		//VFX on top because I needed ball glow behind ball. Might add second VFX function on top later//
	drawVFX();
	drawStuff();

	lastTick = curTick;

	window.requestAnimationFrame(update);
}

function pausable(dt) {
	time++;

	if(ai && game) runAI(dt);
	if(touch.x != 0 && touch.y != 0){
		if(touch.y > p1.position.y) {
			up = false;
			down = true;
		}
		if(touch.y < p1.position.y) {
			up = true;
			down = false;
		}
	}

	if(up) {
		p1.velocity = p1.velocity.add(new Vector2(0,-0.03)).limit(0.8);
	}
	if(down) {
		p1.velocity = p1.velocity.add(new Vector2(0,0.03)).limit(0.8);
	}
	if(!up && !down) {
		p1.velocity = p1.velocity.multiply(0.93);
		if(p1.velocity.magnitude() < 0.05) p1.velocity = new Vector2(0,0);
	}
	
	if(up2) {
		p2.velocity = p2.velocity.add(new Vector2(0,-0.03)).limit(0.8);
	}
	if(down2) {
		p2.velocity = p2.velocity.add(new Vector2(0,0.03)).limit(0.8);
	}
	if(!up2 && !down2) {
		p2.velocity = p2.velocity.multiply(0.93);
		if(p2.velocity.magnitude() < 0.05) p2.velocity = new Vector2(0,0);
	}

	checkCollisions();

	p1.position = p1.position.add(p1.velocity.multiply(dt*SMag));
	p1.position.y = clamp(p1.position.y,80*SMag+p1.getHeight()/2,gHeight-p1.getHeight()/2);
	p2.position = p2.position.add(p2.velocity.multiply(dt*SMag));
	p2.position.y = clamp(p2.position.y,80*SMag+p2.getHeight()/2,gHeight-p2.getHeight()/2);
	ball.position = ball.position.add(ball.velocity.multiply(dt*SMag));
}

///////////////////////////////////////////////////////////////////////////
//                               Collisions                              //
///////////////////////////////////////////////////////////////////////////

		//TODO: SFX//
function checkCollisions() {
		//Check paddle collisions//
		//TODO: Check for collisions between ball position and next position, can currently skip over paddle around .9 speed
	var pw = p1.getWidth()/2;
	var ph = p1.getHeight()/2;
	if((ball.position.x <= p1.position.x + pw && ball.position.x > p1.position.x && ball.position.y < p1.position.y + ph && ball.position.y > p1.position.y - ph) || 
	   (ball.position.x >= p2.position.x - pw && ball.position.x < p2.position.x && ball.position.y < p2.position.y + ph && ball.position.y > p2.position.y - ph)) {
		ball.velocity = ball.velocity.hadamard(new Vector2(-1,1));
		ball.glow = ball.velocity.magnitude() * 5;
		if(ball.velocity.x > 0) {
			var slope = -(ball.position.y - p1.position.y) / 5;
			ball.velocity = ball.velocity.rotate(Math.atan(slope ** -1)/2);
			if(right) {
				ball.velocity = ball.velocity.add(new Vector2(0.05,0));
				ball.glow += 2;
			}
			ballColor = p1Color;
		}
		if(ball.velocity.x < 0) {
			var slope = (ball.position.y - p2.position.y) / 5;
			ball.velocity = ball.velocity.rotate(Math.atan(slope ** -1)/2);
			if(left2) {
				ball.velocity = ball.velocity.add(new Vector2(-0.05,0));
				ball.glow += 2;
			}
			ballColor = p2Color;
		}
		ball.position.x = clamp(ball.position.x, p1.position.x + 5, p2.position.x - 5);
		ballColor2 = colorToRGB(ballColor);

		playBump(-1);
		
		hits++;
		hit();
		speed();
		projTraj();
	}
		//Check top/bottom collisions//
	if(ball.position.y <= 80*SMag + ball.getRadius() || ball.position.y >= gHeight - 4) {
		ball.position.y = clamp(ball.position.y, 80*SMag + ball.getRadius(), gHeight-4);
		ball.velocity = ball.velocity.hadamard(new Vector2(1,-1));
		if((ball.velocity.angle() < Math.PI - 0.05 && ball.velocity.angle() > Math.PI/2) || (ball.velocity.angle() < 0.05 && ball.velocity.angle() > -Math.PI/2)) {
			ball.velocity = ball.velocity.rotate(Math.PI/32);
		} else if((ball.velocity.angle() > -Math.PI + 0.05 && ball.velocity.angle() < -Math.PI/2) || (ball.velocity.angle() > -0.05 && ball.velocity.angle() < Math.PI/2)) {
			ball.velocity = ball.velocity.rotate(-Math.PI/32);
		}
		if(win == "bounces") {
			if(ballColor == p1Color){
				p1Score++;
				score();
			}else if(ballColor == p2Color) {
				p2Score++;
				score();
			}
		}

		playBump(-1);

		ball.glow = ball.velocity.magnitude();
		projTraj();
	}
		//Check right collision//
	if(ball.position.x > gWidth) {
		p1Score++;
		rounds++;
		score();
		goalTarg = new Vector2(ball.position.x, ball.position.y);
		goalColor = ballColor;
		goalGlow = 0;
		if(((win == "points" || win == "bounces") && winCount <= p1Score) || 
		   (win == "rounds" && winCount <= rounds)) {
			gameOver();
			return;
		}
		hits = 0;
		hit();

		ball = new Ball();
		speed();
		projTraj();
	}
		//Check left collision//
	if(ball.position.x < 0) {
		p2Score++;
		rounds++;
		score();
		goalTarg = new Vector2(ball.position.x, ball.position.y);
		goalColor = ballColor;
		goalGlow = 0;
		if(((win == "points" || win == "bounces") && winCount <= p2Score) || 
		   (win == "rounds" && winCount <= rounds)) {
			gameOver();
			return;
		}
		hits = 0;
		hit();

		ball = new Ball();
		speed();
		projTraj();
	}
}

///////////////////////////////////////////////////////////////////////////
//                                   AI                                  //
///////////////////////////////////////////////////////////////////////////

function runAI(dt) {
		//Periodically check where the ball will go//
	if(time % 50 == 0) {
		projTraj();
	}
		//Periodically switch animations//
	if(time % 737 == 0) {
		pai.idleNum = Math.floor(Math.random()*4);
		if(time % 10 > pai.animation * 10) pai.idleNum = -1;
	}

	down2 = false;
	up2 = false;
	if(pai.guess) {	//Get ready for the ball//
		pai.idleRange = null;
		if(p2.position.y < pai.goalRange.a) {
			down2 = true;
			up2 = false;
		}
		if(p2.position.y > pai.goalRange.b) {
			down2 = false;
			up2 = true;
		}
		//power shot//
		if(ball.position.x > p2.position.x-(2*ball.velocity.x*dt) && time % 10 < pai.aggression * 10) left2 = true;
	} else {	//Animate//
		left2=false;
		//Animation target location//
		if(time % 150 == 0) {
			var idleTarget = Math.random() * (gHeight - 92) + 92;
			var mod = Math.random() * 50 * pai.animation;
			pai.idleRange = new Range(idleTarget - mod, idleTarget + mod).limit(92, gHeight);
		}
		//Go back and forth across target location//
		if(pai.idleRange && pai.idleNum == 0) {
			if(p2.position.y < ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)) {
				down2 = true;
				up2 = false;
			}
			if(p2.position.y > ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)) {
				down2 = false;
				up2 = true;
			}
			if(p2.position.y < ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)+10 && p2.position.y > ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)-10) {
				pai.idleDir = !pai.idleDir;
			}
		}
		//Nudge back and forth across target location//
		if(pai.idleRange && pai.idleNum == 1) {
			if(p2.position.y < ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)) {
				if(time % 150 < 20) {
					down2 = true;
					up2 = false;
				}
			}
			if(p2.position.y > ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)) {
				if(time % 150 < 20) {
					down2 = false;
					up2 = true;
				}
			}
			if(p2.position.y < ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)+10 && p2.position.y > ((pai.idleDir) ? pai.idleRange.b : pai.idleRange.a)-10) {
				pai.idleDir = !pai.idleDir;
			}
		}
		//Track ball//
		if(pai.idleNum == 2) {
			if(p2.position.y < ball.position.y) {
				down2 = true;
				up2 = false;
			}
			if(p2.position.y > ball.position.y) {
				down2 = false;
				up2 = true;
			}
		}
		//Track opponent//
		if(pai.idleNum == 3) {
			if(p2.position.y < p1.position.y - 25) {
				down2 = true;
				up2 = false;
			}
			if(p2.position.y > p1.position.y + 25) {
				down2 = false;
				up2 = true;
			}
		}
	}
}

function projTraj() {
	if(!game) return;
	if(ai) pai.guess = null;
	goal = null;

	var pw = p1.getWidth()/2;
	var tl = new Vector2(p1.position.x+pw, 80*SMag);
	var tr = new Vector2(p2.position.x-pw, 80*SMag);
	var br = new Vector2(p2.position.x-pw, gHeight);
	var bl = new Vector2(p1.position.x+pw, gHeight);
	var top = new Line(tl, tr);
	var right = new Line(tr, br);
	var bottom = new Line(br, bl);
	var left = new Line(bl, tl);

	hitPoints = [];
	var traj = new Line(ball.position, ball.position.add(ball.velocity));
	var trajVel = new Vector2(ball.velocity.x, ball.velocity.y);
		//Collect the points where the ball should hit the wall sequentially//
	for(i=0;i<3;i++){
		if(trajVel.x > 0) {
			if(traj.intersect(right)){
				hitPoints[hitPoints.length]=traj.intersect(right);
				trajVel = trajVel.hadamard(new Vector2(-1,1));
				if(!goal) goal = hitPoints[hitPoints.length-1];
				
				let index = i;
				if (ai &&
				    ball.velocity.x > 0 &&
				   (hitPoints.length < pai.attention*2+2) && 
				   (ball.position.x > (gWidth/2)-(gWidth/2*pai.attention))) {
					guessHit(hitPoints[hitPoints.length-1], index);
				}
			}
		} else if(trajVel.x < 0) {
			if(traj.intersect(left)){
				hitPoints[hitPoints.length]=traj.intersect(left);
				trajVel = trajVel.hadamard(new Vector2(-1,1));
				if(!goal) goal = hitPoints[hitPoints.length-1];
			}
		}
		if(trajVel.y > 0) {
			if(traj.intersect(bottom)){
				hitPoints[hitPoints.length]=traj.intersect(bottom);
				trajVel = trajVel.hadamard(new Vector2(1,-1));
			}
		} else if(trajVel.y < 0) {
			if(traj.intersect(top)){
				hitPoints[hitPoints.length]=traj.intersect(top);
				trajVel = trajVel.hadamard(new Vector2(1,-1));
			}
		}
		
		if(hitPoints.length == 0) return;
		traj = new Line(hitPoints[hitPoints.length-1], hitPoints[hitPoints.length-1].add(trajVel));
	}
}

		//The illusion of human error//
function guessHit(project, index) {
	if(!pai.guess) {
		var distance = (p2.position.x - ball.position.x + ((ball.velocity.x < 0) ? (ball.position.x - p1.position.x) * 2 : 0));
		var mod = SMag * (2+index) * distance / (pai.accuracy*18+2);
		pai.guessRange = new Range(project.y - mod, project.y + mod).limit(92, gHeight);
		pai.guess = new Vector2(project.x, pai.guessRange.random());
		mod = SMag * (2+index) * distance / (pai.urgency*10+10);
		pai.goalRange = new Range(pai.guess.y - mod, pai.guess.y + mod).limit(92, gHeight);
	}
}

///////////////////////////////////////////////////////////////////////////
//                                Drawing                                //
///////////////////////////////////////////////////////////////////////////

function drawStuff() {
	ctx.strokeStyle = "#FFFFFF";
	ctx.lineWidth = 1;
	ctx.fillStyle = "#FFFFFF";

		//draw ball//
	if(game) {
		ctx.beginPath();
		ctx.fillStyle = ballColor;
		ctx.arc(ball.position.x,ball.position.y,ball.getRadius(),0,Math.PI * 2,true);
		ctx.fill();
	}

		//draw paddles//
	ctx.beginPath();
	ctx.fillStyle = p1Color;
	ctx.fillRect(p1.position.x-(p1.getWidth()/2),p1.position.y-(p1.getHeight()/2),p1.getWidth(),p1.getHeight());
	ctx.beginPath();
	ctx.fillStyle = p2Color;
	ctx.fillRect(p2.position.x-(p2.getWidth()/2),p2.position.y-(p2.getHeight()/2),p2.getWidth(),p2.getHeight());

	if(showAI && pai) {
		//draw ball's trajectory//
		if(showBallPath) {
			ctx.beginPath();
			ctx.strokeStyle = "#FF0000";
			ctx.lineWidth = 3;
			var trajDraw = ball.position;
			for(i=0;i<hitPoints.length;i++) {
				ctx.moveTo(trajDraw.x,trajDraw.y);
				ctx.lineTo(hitPoints[i].x,hitPoints[i].y);
				ctx.stroke();
				trajDraw = hitPoints[i];
			}
		}
		//draw next goal mark//
		if(showGoalHit && goal != null) {
			ctx.beginPath();
			ctx.strokeStyle = "#FF0000";
			ctx.lineWidth = 1;
			ctx.arc(goal.x,goal.y,8,0,Math.PI*2,true);
			ctx.stroke();
		}
		//draw where ai guesses the goal will be//
		if(ai && showGoalGuess && pai.guess !=null) {
			ctx.beginPath();
			ctx.strokeStyle = "#0000FF";
			ctx.lineWidth = 1;
			ctx.arc(pai.guess.x,pai.guess.y,8,0,Math.PI*2,true);
			ctx.stroke();
		}
		//draw range where ai might guess goal will be//
		if(ai && showGuessRange && pai.guess != null) {
			ctx.beginPath();
			ctx.strokeStyle = "#0000FF";
			ctx.lineWidth = 2;
			ctx.moveTo(pai.guess.x-5, pai.guessRange.a);
			ctx.lineTo(pai.guess.x+5, pai.guessRange.a);
			ctx.moveTo(pai.guess.x-5, pai.guessRange.b);
			ctx.lineTo(pai.guess.x+5, pai.guessRange.b);
			ctx.stroke();
		}
		//draw how far from goal guess ai is comfortable staying//
		if(ai && showGoalRange && pai.guess) {
			ctx.beginPath();
			ctx.strokeStyle = "#FFFF00";
			ctx.lineWidth = 3;
			ctx.moveTo(p2.position.x, pai.goalRange.a);
			ctx.lineTo(p2.position.x, pai.goalRange.b);
			ctx.stroke();
		}
	}
}

function drawVFX() {
		//draw impact glow around ball//
	if(ball.glow > 0) {
		ctx.beginPath();
		gradient = ctx.createRadialGradient(ball.position.x, ball.position.y, 5*SMag, ball.position.x, ball.position.y, (5+(ball.glow*4))*SMag);
		gradient.addColorStop(0.1,`rgba(${ballColor2.join(",")},1)`);
		gradient.addColorStop(0.8,`rgba(${ballColor2.join(",")},0.3)`);
		ctx.fillStyle = gradient;
		ctx.arc(ball.position.x,ball.position.y,(5+(ball.glow*4))*SMag,0,Math.PI*2);
		ctx.fill();
		ball.glow -= 0.1;
		if(ball.glow < 0) ball.glow = 0;
	}
		//draw goal glow//
	if(goalTarg) {
		ctx.beginPath();
		gradient = ctx.createRadialGradient(goalTarg.x, goalTarg.y, SMag, goalTarg.x, goalTarg.y, goalGlow*SMag);
		var goalColor2 = colorToRGB(goalColor);
		gradient.addColorStop(0.1,`rgba(${goalColor2.join(",")},0.9)`);
		gradient.addColorStop(0.9,`rgba(${goalColor2.join(",")},0.2)`);
		ctx.fillStyle = gradient;
		ctx.arc(goalTarg.x, goalTarg.y, goalGlow*SMag, 0, Math.PI*2);
		ctx.fill();
		goalGlow+=10;
		if(goalGlow > 200) {
			goalTarg = null;
		}
	}
}

///////////////////////////////////////////////////////////////////////////
//                                Utility                                //
///////////////////////////////////////////////////////////////////////////

function clamp(value, min, max) {
	return Math.min(Math.max(value, min), max);
}

	//Returns -1 or 1 if the value isn't 0//
function sign(value) {
	if(!value) return 0;
	return value / Math.abs(value)
}

function checkColors() {
	var s = new Option().style;
	s.color = p1Color;
	if(s.color == "") p1Color = "white";
	s.color = null;
	s.color = p2Color;
	if(s.color == "") p2Color = "white";
}

function colorToRGB(string) {
	ctx.beginPath();
	ctx.fillStyle = string;
	ctx.fillRect(0,0,1,1);
	var pixel = ctx.getImageData(0,0,1,1).data;
	return [pixel[0],pixel[1],pixel[2]];
}

//-----------------------------------------------------------------------//
		</script>
	</head>
	<body onload="loadStuff()" onkeydown="kDown(event)" onkeyup="kUp(event)">
		<h1 id="title">Pung</h1>
		<canvas id="playground"></canvas>
		<div id="status">
			<div id="scorediv" style="margin-left: 1px">
				<span id="p1score"></span><br />
				<span id="p2score"></span>
			</div>
			<div id="hitsdiv">
				<span id="hits"></span><br>
				<span id="hitsmax"></span>
			</div>
			<div id="ballspeeddiv">
				<span id="speed"></span><br>
				<span id="speedmax"></span>
			</div>
			<div id="testdiv" style="overflow: visible">

			</div>
		</div>
		<div id="menu">
			<h2>Menu</h2>
			<div id="left" class="half">
				<h3>Game Settings</h3>
				<div class="margin">
					<hr /><br />
					Player 1 Name: <input id="name-p1" type="text" value="Player 1" />
					Color: <input id="color-p1" type="text" value="white" /><br /><br /><br />
					<hr /><br />
					<strong>Win by:</strong> <br />
					<label for="win-rounds">Rounds? <input id="win-rounds" type="radio" name="win" value="rounds" /></label>
					Number: <input id="count-rounds" type="number" value=20 /><br />
					<label for="win-points">Points? <input id="win-points" type="radio" name="win" value="points" checked /></label>
					Number: <input id="count-points" type="number" value=10 /><br />
					<label for="win-bounces">Bounces? <input id="win-bounces" type="radio" name="win" value="bounces" /></label>
					Number: <input id="count-bounces" type="number" value=50 /><br />
					<label for="win-never">Never? <input id="win-never" type="radio" name="win" value="never" /></label>
				</div>
			</div>
			<div id="right" class="half">
				<h3>Player 2</h3>
				<div class="margin">
					<hr /><br />
					<label for="player-human">Human? <input id="player-human" type="radio" name="player" value="human" /></label>
					Name: <input id="name-p2" type="text" value="Player 2" /> 
					Color: <input id="color-p2" type="text" value="white" /><br />
					<label for="player-ai">AI? <input id="player-ai" type="radio" name="player" value="ai" checked /></label>
					Model: <select id="name-ai">
						<option value=0>Lenny</option>
						<option value=1>Martha</option>
						<option value=2>Barry</option>
						<option value=3>Helga</option>
						<option value=4>Sam</option>
					</select><br /><br />
					<hr /><br />
					<div id="mod-tab" class="tab" onclick="toggleTab('mod')">AI Models</div>
					<div id="vis-tab" class="tab" onclick="toggleTab('vis')" style="right:40px">AI Visuals</div>
					<div id="mod-div" class="tab-content" style="display:none"> <!--name,color,attention,accuracy,urgency,animation-->
						<label for="ai-name">Name: <input id="ai-name" type="text"></label><br />
						<label for="ai-color">Color: <input id="ai-color" type="text"></label><br />
						<label for="ai-attention">Attention: <input id="ai-attention" class="slider" type="range" min=0 max=1 step=0.01></label><br />
						<label for="ai-accuracy">Accuracy: <input id="ai-accuracy" class="slider" type="range" min=0 max=1 step=0.01></label><br />
						<label for="ai-urgency">Urgency: <input id="ai-urgency" class="slider" type="range" min=0 max=1 step=0.01></label><br />
						<label for="ai-aggression">Aggression: <input id="ai-aggression" class="slider" type="range" min=0 max=1 step=0.01></label><br />
						<label for="ai-animation">Animation: <input id="ai-animation" class="slider" type="range" min=0 max=1 step=0.01></label><br />
						<button onclick="addModel()">Add AI Model</button>
					</div>
					<div id="vis-div" class="tab-content" style="display:none">
						<label for="ai-visuals">AI Visuals: <input id="ai-visuals" type="checkbox" onclick="checkVis()" /></label><br />
						<label for="ai-ball-path">Ball Path: <input id="ai-ball-path" class="vis-check" type="checkbox" checked disabled /></label><br />
						<label for="ai-goal-hit">Goal Hit: <input id="ai-goal-hit" class="vis-check" type="checkbox" checked disabled /></label><br />
						<label for="ai-guess-range">AI Guess Range: <input id="ai-guess-range" class="vis-check" type="checkbox" disabled /></label><br />
						<label for="ai-goal-guess">AI Goal Guess: <input id="ai-goal-guess" class="vis-check" type="checkbox" disabled /></label><br />
						<label for="ai-goal-range">AI Goal Zone: <input id="ai-goal-range" class="vis-check" type="checkbox" disabled /></label><br />
					</div>
				</div>
			</div>
			<button id="newgame" onclick="newGame()">New Game</button>
		</div>
		<div id="splash">
			<span id="splash-title"></span><br />
			<button onclick="menu()">Menu</button>
		</div>
	</body>
</html>